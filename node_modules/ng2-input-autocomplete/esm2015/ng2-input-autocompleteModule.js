import { Component, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, HostListener, Input, NgModule, Output, ViewContainerRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
  MIT LICENSE @liuy97
*/
class AutocompleteComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.selectEvent = new EventEmitter();
        this.inputChangedEvent = new EventEmitter();
        this.thisElement = elementRef.nativeElement;
        this.selectedIndex = 0;
        this.showAutoComplete = false;
        this.value = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.placeholder = 'autocomplete';
        this.inputElement = /** @type {?} */ (this.thisElement.querySelector('input'));
        if (!this.isNull(this.config)) {
            if (!this.isNull(this.config.placeholder)) {
                this.placeholder = this.config.placeholder;
            }
            if (!this.isNull(this.config.sourceField)) {
                this.sourceField = this.config.sourceField;
            }
        }
        this.filterItems(this.value);
        this.inputElement.focus();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.filterItems(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    enterText(event) {
        const /** @type {?} */ total = this.candidates.length;
        switch (event.keyCode) {
            case 27:
                this.showAutoComplete = false;
                break;
            case 38:
                this.selectedIndex = (total + this.selectedIndex - 1) % total;
                break;
            case 40:
                this.selectedIndex = (total + this.selectedIndex + 1) % total;
                break;
            case 13:
                if (this.candidates.length > 0) {
                    this.onSelect(this.selectedIndex);
                }
                event.preventDefault();
                break;
            default:
                this.value = event.target.value;
                this.inputChangedEvent.emit(this.value);
                break;
        }
    }
    /**
     * @param {?} idx
     * @return {?}
     */
    onSelect(idx) {
        this.showAutoComplete = false;
        this.value = this.candiatesLabels[idx];
        this.selectEvent.emit(this.candidates[idx]);
    }
    /**
     * @param {?} search
     * @return {?}
     */
    filterItems(search) {
        const /** @type {?} */ field = this.sourceField;
        const /** @type {?} */ filterItem = this.filterItem;
        if (this.items) {
            this.candidates = this.items.filter(item => {
                return filterItem(item, field, search);
            });
            this.buildLabels();
        }
    }
    /**
     * @param {?} object
     * @param {?} path
     * @return {?}
     */
    getFieldValue(object, path) {
        if (typeof object === 'string') {
            return object;
        }
        if (path instanceof Array) {
            let /** @type {?} */ result = object;
            path.forEach((element) => {
                if (result !== null &&
                    result !== undefined &&
                    result[element] !== null &&
                    result[element] !== undefined) {
                    result = result[element];
                }
                else {
                    result = '';
                }
            });
            return result;
        }
        else {
            return object[path] || '';
        }
    }
    /**
     * @param {?} object
     * @return {?}
     */
    isNull(object) {
        return object === null || object === undefined;
    }
    /**
     * @return {?}
     */
    buildLabels() {
        const /** @type {?} */ field = this.sourceField;
        const /** @type {?} */ getFieldValue = this.getFieldValue;
        this.candiatesLabels = this.candidates.map((e) => getFieldValue(e, field));
    }
    /**
     * @param {?} item
     * @param {?} path
     * @param {?} search
     * @return {?}
     */
    filterItem(item, path, search) {
        if (search === null || search === undefined || search.length === 0) {
            return true;
        }
        let /** @type {?} */ result;
        if (typeof item === 'string') {
            result = item;
        }
        else if (path instanceof Array) {
            result = item;
            path.forEach((element) => {
                if (result !== null &&
                    result !== undefined &&
                    result[element] !== null &&
                    result[element] !== undefined) {
                    result = result[element];
                }
                else {
                    result = '';
                }
            });
        }
        else {
            result = item[path] || '';
        }
        return result.toLowerCase().indexOf(search.toLowerCase()) >= 0;
    }
}
AutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng2-input-autocomplete',
                template: `
  <div class="autocomplete">
    <input type="text"
      placeholder="{{placeholder}}"
      (blur)="showAutoComplete = false;"
      (focus)="showAutoComplete = true;"
      [value]="value"
      (keyup)="enterText($event)">
    <ul *ngIf="showAutoComplete && candidates && candidates.length > 0">
      <li *ngFor="let candidate of candidates; let idx = index"
        [ngClass]="{ active: (idx === selectedIndex) }"
        (mouseover)="selectedIndex = idx;"
        (mousedown)="onSelect(idx)">
        {{candiatesLabels[idx]}}
      </li>
    </ul>
  </div>`,
                styles: [
                    `.autocomplete ul {
       position: absolute;
       left: 0;
       width: 100%;
       border-left: 1px solid #888;
       border-right: 1px solid #888;
       border-bottom: 1px solid #888;
       list-style: none;
       padding-left: 0px;
       margin-top: 2px;
       background-color: #fff;
       z-index: 100;
     }
     .autocomplete li {
       text-align: left;
       list-style: none;
       width: 100%;
       padding: 0.4em 0 0.4em 0;
     }
     .autocomplete li.active {
       width: 100%;
       background-color: #4bf;
     }

     .autocomplete .highlight {
       background-color: #e2e2e2;
     }
     .autocomplete li.active .highlight {
       background: #666;
       color: #fff;
     }`
                ]
            },] },
];
/** @nocollapse */
AutocompleteComponent.ctorParameters = () => [
    { type: ElementRef, },
];
AutocompleteComponent.propDecorators = {
    "items": [{ type: Input },],
    "config": [{ type: Input },],
    "selectEvent": [{ type: Output },],
    "inputChangedEvent": [{ type: Output },],
};
class AutocompleteDirective {
    /**
     * @param {?} resolver
     * @param {?} viewContainerRef
     */
    constructor(resolver, viewContainerRef) {
        this.resolver = resolver;
        this.viewContainerRef = viewContainerRef;
        this.ngModelChange = new EventEmitter();
        this.inputChangedEvent = new EventEmitter();
        this.selectEvent = new EventEmitter();
        this.hideAutocomplete = (event) => {
            if (!this.componentRef) {
                return;
            }
            if (!event ||
                (event.target !== this.thisElement && event.type === 'click')) {
                this.componentRef.destroy();
                this.componentRef = undefined;
            }
            if (this.inputElement['tabIndex'] < 0) {
                this.inputElement['tabIndex'] = this.tabIndex;
            }
        };
        this.onInputChanged = (val) => {
            this.inputElement.value = val;
            if (val !== this.ngModel) {
                this.ngModelChange.emit(val);
            }
            const /** @type {?} */ component = this.componentRef.instance;
            component.filterItems(val);
            this.inputChangedEvent.emit(val);
        };
        this.onSelect = (item) => {
            const /** @type {?} */ component = this.componentRef.instance;
            const /** @type {?} */ val = component.value;
            if (val !== this.ngModel) {
                this.ngModelChange.emit(val);
            }
            this.selectEvent.emit(item);
            if (this.inputElement) {
                this.inputElement.value = '' + val;
            }
            this.hideAutocomplete();
        };
        this.thisElement = this.viewContainerRef.element.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.thisElement.tagName.toLowerCase() === 'form') {
            return;
        }
        this.createDiv();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.instance.selectEvent.unsubscribe();
            this.componentRef.instance.inputChangedEvent.unsubscribe();
        }
        document.removeEventListener('click', this.hideAutocomplete);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['items'] && this.componentRef) {
            const /** @type {?} */ component = this.componentRef.instance;
            component.items = changes['items'].currentValue;
            component.filterItems(component.value);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    showAutocomplete(event) {
        this.hideAutocomplete();
        if (event === this.thisElement) {
            this.createAutocomplete();
        }
    }
    /**
     * @return {?}
     */
    createDiv() {
        const /** @type {?} */ element = document.createElement('div');
        element.style.display = 'inline-block';
        element.style.position = 'relative';
        this.thisElement.parentElement.insertBefore(element, this.thisElement.nextSibling);
        element.appendChild(this.thisElement);
        document.addEventListener('click', this.hideAutocomplete);
    }
    /**
     * @return {?}
     */
    createAutocomplete() {
        const /** @type {?} */ factory = this.resolver.resolveComponentFactory(AutocompleteComponent);
        this.componentRef = this.viewContainerRef.createComponent(factory);
        const /** @type {?} */ component = this.componentRef.instance;
        component.config = this.config;
        component.items = this.items;
        component.selectEvent.subscribe(this.onSelect);
        component.inputChangedEvent.subscribe(this.onInputChanged);
        this.autocompleteElement = this.componentRef.location.nativeElement;
        this.autocompleteElement.style.display = 'none';
        this.inputElement = /** @type {?} */ (this.thisElement);
        if (this.thisElement.tagName !== 'INPUT' && this.autocompleteElement) {
            this.inputElement = /** @type {?} */ (this.thisElement.querySelector('input'));
            this.inputElement.parentElement.insertBefore(this.autocompleteElement, this.inputElement.nextSibling);
        }
        component.value = this.inputElement.value;
        this.tabIndex = this.inputElement['tabIndex'];
        this.inputElement['tabIndex'] = -100;
        if (this.componentRef) {
            const /** @type {?} */ rect = this.thisElement.getBoundingClientRect();
            const /** @type {?} */ style = this.autocompleteElement.style;
            style.width = rect.width + 'px';
            style.position = 'absolute';
            style.zIndex = '1';
            style.top = '0';
            style.left = '0';
            style.display = 'inline-block';
        }
    }
}
AutocompleteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[autocomplete]'
            },] },
];
/** @nocollapse */
AutocompleteDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver, },
    { type: ViewContainerRef, },
];
AutocompleteDirective.propDecorators = {
    "config": [{ type: Input },],
    "items": [{ type: Input },],
    "ngModel": [{ type: Input },],
    "ngModelChange": [{ type: Output },],
    "inputChangedEvent": [{ type: Output },],
    "selectEvent": [{ type: Output },],
    "showAutocomplete": [{ type: HostListener, args: ['click', ['$event.target'],] }, { type: HostListener, args: ['focus', ['$event.target'],] },],
};
class AutocompleteModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AutocompleteModule
        };
    }
}
AutocompleteModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                declarations: [AutocompleteComponent, AutocompleteDirective],
                exports: [AutocompleteComponent, AutocompleteDirective],
                entryComponents: [AutocompleteComponent]
            },] },
];
/** @nocollapse */
AutocompleteModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { AutocompleteComponent, AutocompleteDirective, AutocompleteModule };
//# sourceMappingURL=ng2-input-autocompleteModule.js.map
